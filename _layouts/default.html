<!DOCTYPE html>
<html lang="{{ site.lang | default: "en-US" }}">
  <head>
    <meta charset="UTF-8">
    <title>SKIP-LIST</title>
    <meta name="description" content="{{ page.description | default: site.description | default: site.github.project_tagline }}"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=open+sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="{{ '/assets/css/style.css?v=' | append: site.github.build_revision | relative_url }}">
  </head>

  <body>
    <section class="page-header">
      <h1 class="project-name">SKIP-LIST</h1>
      <h2 class="project-tagline">A probabilistic alternative to balanced trees</h2>
      {% if site.github.is_project_page %}
        <a href="https://github.com/rajatjain92/SKIP-LIST" class="btn">View on GitHub</a>
      {% endif %}
     
        <a href="https://github.com/rajatjain92/SKIP-LIST/zipball/master" class="btn">Download .zip</a>
        <a href="https://github.com/rajatjain92/SKIP-LIST/tarball/master" class="btn">Download .tar.gz</a>
    </section>
    <section class="main-content">
    <p>
    Skip lists are data structures which are used in place of balanced trees. 
    It uses probabilistic balancing rather than enforced strict balancing like in BST,AVL etc hence 
    as a result its algorithms are simpler and significantly faster than algorithms in case of BST , AVL etc.</p>
 
    <h2>ABSTRACT</h2>
Binary trees are used for representing abstract data types such as dictionaries and ordered lists. 
It works better when elements are inserted in random order but when elements are inserted in order(particular order) it gives poor performance. 
It means there is an input sequence which consistently gives worst case
      If it is possible to randomly permute the input it works well with high probability . 
<b>But in information retrieval queries must be answered on-line so randomly permuting the input is impractical.</b> 
    In binary tree we satisfy certain balance conditions and assure good performance.
 </p> 
 
<p>SKIP-LISTS are probabilistic alternative to balanced trees.
  They are balanced by consulting a random number generator. 
  <b>Skip lists have bad worst-case performance,but no input sequence consistently produce worst case.( like random Quick sort probability is involved here  ) . 
    It is very unlikely a skip list data structure will be significantly unbalanced.</b> 
  Skip lists have balanced properties similar to search trees built by random insertions , <b>yet do not require insertions to be random. </b>
  Skip lists do not require input sequence to be random , it consults random number generator for balancing.</p> 
 <p> 
Skip lists are also very space efficient. 
  They can be configured to require an average of 1.33 pointers per element (or even less) and
  do not require balance or priority information to be stored with each node.</p>
    
  <h2>TAG-LINE</h2><p>BALANCING A DATA STRUCTURE PROBABILISTICALLY IS EASIER THAN EXPLICITLY MAINTAINING THE BALANCE.</p>

      
<h2>SKIP-LIST</h2>
<p> 
  In the below figure (list is sorted in every case)</p>
  <ul>
    <li>In this case while searching we have to examine every node.</li>
<li>In this every other node has a pointer to 2 nodes ahead in list. While searching we have to examine atmost ceil(n/2)+1.</li>
    <li>In  this case every 4<sup>th</sup> node has a pointer to 4 nodes ahead. We dont require more than ceil(n/4)+1 nodes to be examined.</li>
    <li>In this every 2<sup>i</sup> node has a pointer 2<sup>i</sup> nodes ahead. Examined nodes would be reduced to order ceil(logn). 
      This implementation can be used for fast searching but insertion and deletion would be impractical in this implementation.
      (every 2<sup>nd</sup> node has pointer 2 nodes ahead; every 4<sup>th</sup> node has pointer 4 nodes ahead and so on.) 
      and i<sup>th</sup> forward pointer of node points to 2<sup>i-1</sup> nodes ahead.</li> 
      </ul>   
<h4>ABOVE IMPLEMENTATION SHOULD BE USED WHEN ONLY FAST SEARCHING IS TO BE DONE.(NO INSERTION OR DELETION)	</h4>
 
    <img src="images/1.png" alt="hiii" class="inline"/>
    <center>Fig 1</center>
    <br>
    <ul>
   <li>A node having k forward pointers is level k node.</li>
   <li>If every 2<sup>i</sup> node has  pointer 2<sup>i</sup> nodes ahead then levels are distributed in a simple pattern :50% are level 1 , 
 25% are level 2 , 12.5% are level 3 and so on.Till now the implementation we have discussed , no randomness is embedded in that.</li>
      </ul>  
 
 <h2>MAIN IMPLEMENTATION: </h2>
<p>What would happen if levels of nodes were chosen randomly but in same proportions (percentage) discussed above like eg (e).
In (e) a nodeâ€™s ith forward pointer instead of pointing 2<sup>i-1</sup> nodes ahead , points to next node of level i or higher.
Insertion and deletion would require only local modification;the level of node is chosen randomly when node is inserted and never change
    </p>   

<p>
each element is represented by a node having key value pair,the level of which is chosen at random when the node is inserted without
regard for number of elements in it.level i means i forward pointers(1 to i).We do not need to store the level of node in the node.
MAX_LEVEL variable represents max level permitted. The level variable represents the current max level in the list or 1 if the list is 	empty. the header of list has forward pointers at levels 1 to MAX_LEVEL. Forward pointers of header above current maximum level of lists 	point to NIL.
</p>

<p>
	Understanding of NIL is very important.We will discuss some later.
</p>

<h3>Structure of node</h3>

<pre>
	typedef struct node
		{	
			int key;
			int value;
			struct node ** forward; //pointer to a pack of forward pointers
		}node;
</pre> 
	  
<h3>Structure of list</h3>
<pre>
	typedef struct skiplist
		{
			int level;//current max level
			int size;//size of list
			struct node * header;//this is important discussed below
		}skiplist;
</pre>
<img src="images/2.png" alt="hiii" class="inline"/><br>
	  
<h3>Initialisation</h3>
<pr> Consider every node has 2 parts first key-value pair and second part is a pack of forward pointers.Pointer name forward is link between them.
Our first node is special(header node) .It does not carry elements but it behaves as a starting point(only forward pointers no element) and
end point which is NIL.This node is given value INT_MAX to differentiate from others and also helps in stopping while searching.
</pr>	
	  <br>
<pre>

	//only called once
	skiplist * initialise(skiplist *list)
	{
		node * header=(node *)malloc (sizeof(struct node));
		header->key=INT_MAX;
		header->forward=(node **)malloc(sizeof(node *)*(MAX_LEVEL+1));
		list->header=header;

		//forward is pointer to pack of pointers of diff levels 
		for (int i = 0; i <= MAX_LEVEL; ++i)
			header->forward[i]=list->header;//because starting and end point are same.

		list->level=1;//empty list has level 1
		list->size=0;//initially list is empty

		return list;
	}
</pre>

<h3>Searching</h3>
<pre>
	node * search(skiplist * list,int s_key)
	{
		node * x=list->header;
		// list->level bcoz it is the max level at present <=MAX_LEVEL 
		for (int i = list->level; i >= 1; --i)
			while(x->forward[i]->key < s_key)
				x=x->forward[i];
		// x->key < search_key <= x->forward[i]->key
		// < is when value is not present and = when value is present
	
		x=x->forward[1];// 1 because at the end you will be at level 1
		if(x->key == s_key)
			return x;
		else 
			return NULL;
	}
</pre>

<h3>Randomisation</h3>
<pre>
	//A level is chosen for an element in effect by flipping a coin that has probablility p of coming up heads. 
	//We keeping flipping until we get a "tails" or until the maximum number of levels is reached:
	int random_level()
	{
		int new_Level=1;
		while(rand() < p && new_Level < MAX_LEVEL)
			new_Level++;
		return new_Level;
	}
</pre>	


<h3>Insertion</h3>
<pre>
	int insert(skiplist *list,int s_key, int s_value)
	{
		int level;
		node * update[MAX_LEVEL+1];
		node * x=list->header;
		for(int i=list->level; i>=1; i--){
			while(x->forward[i]->key < s_key)
				x=x->forward[i];
			update[i]=x;
		}
		x=x->forward[1];

		if(x->key==s_key)
		{
			x->value=s_value;
			return 0;
		}
		else
		{
			level=random_level();
			if(level > list->level)
			{
				for(int i=list->level+1;i<=level;i++)
					update[i]=list->header;
				list->level=level;
			}
			x=(node *)malloc(sizeof(struct node));
			x->key=s_key;
			x->value=s_value;
			x->forward=(node **)malloc(sizeof(node *)*(level+1));
			for(int i=1; i<= level;i++)
			{
				x->forward[i]=update[i]->forward[i];
				update[i]->forward[i]=x;
			}
		}
		return 0;
	}
</pre>

<h3>Deletion</h3>
<pre>
	int delete(skiplist * list ,int s_key)
	{
		node * update[MAX_LEVEL+1];
		node * x=list->header;
		for (int i = list->level; i >= 1; --i)
		{
			while(x->forward[i]->key < s_key)
				x=x->forward[i];
			update[i]=x;
		}
		x=x->forward[1];
		if(x->key == s_key){
			for (int i = 1; i <= list->level; ++i)
			{
				if(update[i]->forward[i]!=x)
					break;
				update[i]->forward[i]=x->forward[i];
			}
			free(x->forward);
			free(x);
			while(list->level>1 && list->header->forward[list->level]==list->header)
				list->level--;
		}
		return 0;
	}
</pre>

<h3>dumping</h3>
<pre>
	static void dump(skiplist *list)
	 {
    	node *x = list->header;
    	while (x && x->forward[1] != list->header) {
        	printf("%d[%d]->", x->forward[1]->key, x->forward[1]->value);
        	x = x->forward[1];
    	}
    	printf("NIL\n");
	}
</pre>

<h3>Main function</h3>
<pre>
	int main() {
    int arr[] = { 3, 6, 9, 2, 11, 1, 4 }, i;
    skiplist list;
    initialise(&list);
 
    printf("Insert:--------------------\n");
    for (i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
        insert(&list, arr[i], arr[i]);
    }
    dump(&list);
 
    printf("Search:--------------------\n");
    int keys[] = { 3, 4, 7, 10, 111 };
 
    for (i = 0; i < sizeof(keys) / sizeof(keys[0]); i++) {
        node *x = search(&list, keys[i]);
        if (x) {
            printf("key = %d, value = %d\n", keys[i], x->value);
        } else {
            printf("key = %d, not fuound\n", keys[i]);
        }
    }

    printf("Search:--------------------\n");
    delete(&list, 3);
    delete(&list, 9);
    dump(&list);
 
    return 0;
}
</pre>
      
    <footer class="site-footer">
        {% if site.github.is_project_page %}
          <span class="site-footer-owner"><a href="{{ site.github.repository_url }}">{{ site.github.repository_name }}</a> is maintained by <a href="{{ site.github.owner_url }}">{{ site.github.owner_name }}</a>.</span>
        {% endif %}
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>
    {% if site.google_analytics %}
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', '{{ site.google_analytics }}', 'auto');
        ga('send', 'pageview');
      </script>
    {% endif %}
  </body>
</html>
