<!DOCTYPE html>
<html lang="{{ site.lang | default: "en-US" }}">
  <head>
    <meta charset="UTF-8">
    <title>SKIP-LIST</title>
    <meta name="description" content="{{ page.description | default: site.description | default: site.github.project_tagline }}"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=open+sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="{{ '/assets/css/style.css?v=' | append: site.github.build_revision | relative_url }}">
  </head>

  <body>
    <section class="page-header">
      <h1 class="project-name">SKIP-LIST</h1>
      <h2 class="project-tagline">A probabilistic alternative to balanced trees</h2>
      {% if site.github.is_project_page %}
        <a href="https://github.com/rajatjain92/SKIP-LIST" class="btn">View on GitHub</a>
      {% endif %}
     
        <a href="https://github.com/rajatjain92/SKIP-LIST/zipball/master" class="btn">Download .zip</a>
        <a href="https://github.com/rajatjain92/SKIP-LIST/tarball/master" class="btn">Download .tar.gz</a>
    </section>
    <section class="main-content">
    <p>
    Skip lists are data structures which are used in place of balanced trees. 
    It uses probabilistic balancing rather than enforced strict balancing like in BST,AVL etc hence 
    as a result its algorithms are simpler and significantly faster than algorithms in case of BST , AVL etc.</p>
 
    <h2>ABSTRACT</h2>
Binary trees are used for representing abstract data types such as dictionaries and ordered lists. 
It works better when elements are inserted in random order but when elements are inserted in order(particular order) it gives poor performance. 
It means there is an input sequence which consistently gives worst case
      If it is possible to randomly permute the input it works well with high probability . 
<b>But in information retrieval queries must be answered on-line so randomly permuting the input is impractical.</b> 
    In binary tree we satisfy certain balance conditions and assure good performance.
 </p> 
 
<p>SKIP-LISTS are probabilistic alternative to balanced trees.
  They are balanced by consulting a random number generator. 
  <b>Skip lists have bad worst-case performance,but no input sequence consistently produce worst case.( like random Quick sort probability is involved here  ) . 
    It is very unlikely a skip list data structure will be significantly unbalanced.</b> 
  Skip lists have balanced properties similar to search trees built by random insertions , <b>yet do not require insertions to be random. </b>
  Skip lists do not require input sequence to be random , it consults random number generator for balancing.</p> 
 <p> 
Skip lists are also very space efficient. 
  They can be configured to require an average of 1.33 pointers per element (or even less) and
  do not require balance or priority information to be stored with each node.</p>
    
  <h2>TAG-LINE</h2><p>BALANCING A DATA STRUCTURE PROBABILISTICALLY IS EASIER THAN EXPLICITLY MAINTAINING THE BALANCE.</p>

      
<h2>SKIP-LIST</h2>
<p> 
  In the below figure (list is sorted in every case)</p>
  <ul>
    <li>In this case while searching we have to examine every node.</li>
<li>In this every other node has a pointer to 2 nodes ahead in list. While searching we have to examine atmost ceil(n/2)+1.</li>
    <li>In  this case every 4<sup>th</sup> node has a pointer to 4 nodes ahead. We dont require more than ceil(n/4)+1 nodes to be examined.</li>
    <li>In this every 2<sup>i</sup> node has a pointer 2<sup>i</sup> nodes ahead. Examined nodes would be reduced to order ceil(logn). 
      This implementation can be used for fast searching but insertion and deletion would be impractical in this implementation.
      (every 2<sup>nd</sup> node has pointer 2 nodes ahead; every 4<sup>th</sup> node has pointer 4 nodes ahead and so on.) 
      and i<sup>th</sup> forward pointer of node points to 2<sup>i-1</sup> nodes ahead.</li> 
      </ul>   
<h4>THIS IMPLEMENTATION SHOULD BE USED WHEN ONLY FAST SEARCHING IS TO BE DONE.(NO INSERTION OR DELETION)	</h4>
 
<img src="https://github.com/rajatjain92/SKIP-LIST/blob/master/1.png">
Fig 1
 <ul>
   <li>A node having k forward pointers is level k node.</li>
   <li>If every 2<sup>i</sup> node has  pointer 2<sup>i</sup> nodes ahead then levels are distributed in a simple pattern :50% are level 1 , 
 25% are level 2 , 12.5% are level 3 and so on.Till now the implementation we have discussed , no randomness is embedded in that.</li>
      </ul>  
 
 <h5>
What would happen if levels of nodes were chosen randomly but in same proportions (percentage) discussed above like eg (e).
In (e) a nodeâ€™s ith forward pointer instead of pointing 2<sup>i-1</sup> nodes ahead , points to next node of level i or higher.
Insertion and deletion would require only local modification;the level of node is chosen randomly when node is inserted and never change
    </h5>


    
    
    <footer class="site-footer">
        {% if site.github.is_project_page %}
          <span class="site-footer-owner"><a href="{{ site.github.repository_url }}">{{ site.github.repository_name }}</a> is maintained by <a href="{{ site.github.owner_url }}">{{ site.github.owner_name }}</a>.</span>
        {% endif %}
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>
    {% if site.google_analytics %}
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', '{{ site.google_analytics }}', 'auto');
        ga('send', 'pageview');
      </script>
    {% endif %}
  </body>
</html>
